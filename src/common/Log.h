/*
===========================================================================

Daemon GPL Source Code
Copyright (C) 2013 Unvanquished Developers

This file is part of the Daemon GPL Source Code (Daemon Source Code).

Daemon Source Code is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Daemon Source Code is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Daemon Source Code.  If not, see <http://www.gnu.org/licenses/>.

===========================================================================
*/

#include <string>

#include "Cvar.h"
#include "String.h"

#ifndef COMMON_LOG_H_
#define COMMON_LOG_H_

namespace Log {

    /*
     * There are 4 log levels that code can use:
     *   - ERROR when something bad happens TODO: make it crash like Com_Error?
     *   - WARNING when something is not going as expected, it is very visible.
     *   - NOTICE when we want to say something interesting, not very visible.
     *   - DEBUG shouldn't be visible by default.
     */

    enum Level {
        DEBUG,
        NOTICE,
        WARNING,
        ERROR
    };

    // The default filtering level
    const Level DEFAULT_FILTER_LEVEL = WARNING;

    /*
     * Loggers are used to group logs by subsystems and allow logs
     * to be filtered by log level by subsystem. They are used like so
     * in a submodule "Foo" in a module "bar"
     *
     *   static Logger fooLog("bar.foo"); //filters with the default filtering level
     *
     *   fooLog.Warn("%s %i", string, int); //"appends" the newline automatically
     *   fooLog.Debug(<expensive formatting>); //if the log is filtered, no formatting occurs
     *
     * In addition the user/developer can control the filtering level with
     *   /set logs.logLevel.foo.bar {error, warning, info, debug}
     */

    class Logger {
        public:
            Logger(const std::string& name, Level level = DEFAULT_FILTER_LEVEL);

            template<typename ... Args>
            void Error(const std::string& format, Args ... args);

            template<typename ... Args>
            void Warn(const std::string& format, Args ... args);

            template<typename ... Args>
            void Notice(const std::string& format, Args ... args);

            template<typename ... Args>
            void Debug(const std::string& format, Args ... args);

        private:
            // the cvar logs.logLevel.<name>
            Cvar::Cvar<Level> filterLevel;
    };

    /*
     * When debugging a function or before a logger is introduced for
     * a module the following functions can be used for less typing.
     * However it shouldn't stay in production code because it will
     * cannot be filtered and will spoil the console.
     */

    template<typename ... Args>
    void Error(const std::string& foramt, Args ... args);

    template<typename ... Args>
    void Warn(const std::string& foramt, Args ... args);

    template<typename ... Args>
    void Notice(const std::string& foramt, Args ... args);

    template<typename ... Args>
    void Debug(const std::string& foramt, Args ... args);

    /*
     * A log Event, sent to the log system along a list of targets to output
     * it to. Event are not all generated by the loggers (e.g. kill messages)
     */

    struct Event {
        Event(int timestamp, std::string text)
            : timestamp(timestamp), text(std::move(text)) {}
        int timestamp;
        std::string text;
    };

    /*
     * The list of potential targets for a log event.
     * TODO: avoid people having to do (1 << TARGET1) | (1 << TARGET2) ...
     */

    enum TargetId {
        GRAPHICAL_CONSOLE,
        TTY_CONSOLE,
        CRASHLOG,
        LOGFILE,
        GAMELOG,
        HUD,
        MAX_TARGET_ID
    };

    //Internals

    // Functions used for Cvar<Log::Level>
    bool ParseCvarValue(std::string value, Log::Level& result);
    std::string SerializeCvarValue(Log::Level value);

    // Common entry points for all the formatted logs of the same level
    // (decide to which log targets the event goes)
    void CodeSourceError(std::string message);
    void CodeSourceWarn(std::string message);
    void CodeSourceNotice(std::string message);
    void CodeSourceDebug(std::string message);

    // Implementation of templates

    // Logger

    template<typename ... Args>
    void Logger::Error(const std::string& format, Args ... args) {
        CodeSourceError(Str::Format(format, args ...));
    }

    template<typename ... Args>
    void Logger::Warn(const std::string& format, Args ... args) {
        if (filterLevel.Get() <= WARNING) {
            CodeSourceWarn(Str::Format(format, args ...));
        }
    }

    template<typename ... Args>
    void Logger::Notice(const std::string& format, Args ... args) {
        if (filterLevel.Get() <= NOTICE) {
            CodeSourceNotice(Str::Format(format, args ...));
        }
    }

    template<typename ... Args>
    void Logger::Debug(const std::string& format, Args ... args) {
        if (filterLevel.Get() <= DEBUG) {
            CodeSourceDebug(Str::Format(format, args ...));
        }
    }

    // Quick Logs

    template<typename ... Args>
    void Error(const std::string& format, Args ... args) {
        CodeSourceError(Str::Format(format, args ...));
    }

    template<typename ... Args>
    void Warn(const std::string& format, Args ... args) {
        CodeSourceWarn(Str::Format(format, args ...));
    }

    template<typename ... Args>
    void Notice(const std::string& format, Args ... args) {
        CodeSourceNotice(Str::Format(format, args ...));
    }

    template<typename ... Args>
    void Debug(const std::string& format, Args ... args) {
        CodeSourceDebug(Str::Format(format, args ...));
    }
}

namespace Cvar {
    template<>
    std::string GetCvarTypeName<Log::Level>();
}

#endif //COMMON_LOG_H_
